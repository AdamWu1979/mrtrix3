#!/usr/bin/env python

# Script for registration


# Make the corresponding MRtrix3 Python libraries available
import inspect, os, sys
lib_folder = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile(inspect.currentframe()))[0], os.pardir, 'lib')))
if not os.path.isdir(lib_folder):
  sys.stderr.write('Unable to locate MRtrix3 Python libraries')
  sys.exit(1)
sys.path.insert(0, lib_folder)



from mrtrix3 import app, image, path, run

choice_init = ['mass', 'search', 'matrix']
choice_linear_type =['rigid', 'affine']

app.init('MRtrix3 (TODO@gmail.com)','Symmetric linear and nonlinear registration')
app.cmdline.addDescription('mrreg acts as a script for performing various types of registrations')

app.cmdline.add_argument("input", nargs='+', help='example: mrreg 1wm.mif 2wm.mif init[trans=mass] affine[lmax=0 scale=0.3] affine[lmax=2 scale=0.5] affine[lmax=4 scale=1] out[linear=trafo.txt] nl[lmax=0 scale=0.3] nl[lmax=2 scale=0.5] nl[lmax=4 scale=1] out[warp=warp.mif transformed_midway=1_transformed.mif 2_transformed.mif]')

general_options = app.cmdline.add_argument_group('General options')
# general_options.add_argument('-init', choices=choice_init, help='valid choices: '+', '.join(choice_init), default='mass')
# general_options.add_argument('-linear', choices=choice_linear_type, help='valid choices: '+', '.join(choice_linear_type), default='affine')
# general_options.add_argument('-nonlinear', action='store_true', help='run nonlinear registration')
general_options.add_argument('-lmax', help='The maximum harmonic degree(s)')
# general_options.add_argument('-mask1', help='Provide a mask for image1')
# general_options.add_argument('-mask2', help='Provide a mask for image2')
# app.cmdline.flagMutuallyExclusiveOptions( [ 'grad', 'fslgrad' ] )

# mmreg \
# input[ "1 space.mif" 2.mif] \
# init[translation=mass] \
# affine[lmax=0 scale=0.3] affine[lmax=2 scale=0.5] affine[lmax=4 scale=1] \
# nl[lmax=0 scale=0.3] nl[lmax=2 scale=0.5] nl[lmax=4 scale=1]


DEBUG = False
stages = []

def debug(s):
  if DEBUG:
    print('\033[03;34m' +str(s) + '\033[0m')
def quote_ws(s):
  # return pipes.quote(s)
  if s.count(' '):
    debug('fixing quotes: '+str(s)+' --> '+'\''+s+'\'')
    return '\''+s+'\''
  return s

debug("sys.argv")
debug(sys.argv[1:])

import re, subprocess, shlex, pipes
# argument input[ "image 1.mif"] works but not input["image 1.mif"]
# so here we split 'text["something quoted"' off as two arguments: 'text[' and "'something quoted'"
bracket = re.compile('(\w+)\[(\w+.*)')
args = []
for a in sys.argv[1:]:
  m = bracket.findall(a)
  assert (len(m) < 2)
  if not m:
    args.append(a)
  else:
    debug('fix bracket '+a+' --> ' + str(m[0][0]) + '[ ' + str(m[0][1]))
    args += [m[0][0]+'[', quote_ws(m[0][1])] # [quote_ws(s) for s in m[0]]
debug("args:")
debug(args)

# stage parsing
debug("stage parsing")
p = re.compile('\W*(\w+)\[(.*?)\]')
scmd = subprocess.list2cmdline(args)
# scmd = ' '.join([pipes.quote(s) for s in args])
debug("scmd:")
debug(scmd)
parsed = set()

for m in p.finditer(scmd):
  stage_options = []
  debug(m.groups()[1])
  stage_options = shlex.split(m.groups()[1]) # s.split('=')
  # TODO what to do with what= val vs what=val vs what = val
  if m.groups()[0] != 'input':
    debug('stage: ' + m.groups()[0] + ': '+str(stage_options))
  stages.append((m.groups()[0], stage_options))
  parsed = parsed.union(set(range(*m.span())))
toparse=''.join([scmd[i] for i in sorted(list(set(range(0,len(scmd))) - parsed))])

### remove stages from sys.argv
sys.argv = [sys.argv[0]] + toparse.split()
# add dummy argument if no arguments were found to prevent showing help
if len(stages) > 0 and len(toparse.split()) == 0:
  sys.argv.append('%i[stages]'%len(stages))

### command line parsing to handle options
app.parse()



### option parsing
if app.args.lmax:
  app.console('option: -lmax='+app.args.lmax)

### remaining argument parsing
arguments = shlex.split(toparse)
if len(arguments) != 0 and len(arguments) != 2:
  app.error('expected no argument. received: ' + toparse)
if len(arguments):
  stages.insert(0,('input',arguments))

### remove input from processing stages
images = []
current_stages = []
for stage in stages:
  if stage[0] == 'input':
    images.append(stage[1])
  else:
    current_stages.append(stage)
stages = current_stages
app.console ("input images:")
app.console (str(images))

app.console ("stages:")
for i, stage in enumerate(stages):
  debug ('%03i: ' % i +str(stage))

class Sequence:
  def __init__(self):
    self.stages = []
  def add(self, nxt):
    if nxt.add_to_previous:
      assert (len(stages))
      self.stages[-1].options += nxt.add_to_previous
    if nxt.get_command() is not None:
      self.stages.append(nxt)
  def info(self):
    return ['%03i'%i+' '+str(s) for i, s in enumerate(self.stages)]

class Stage:
  In = dict()
  Out = dict()
  add_to_previous = None
  def __init__(self, v):
    self.name = v[0]
    self.command = self.name
    self.options = v[1]

  def __module__(self):
    return self.name

  def __str__(self):
    return "%s: command: %s, options: %s, input: %s output: %s" % (self.name, self.command, self.options, self.In, self.Out)

  def get_command(self):
    return [self.command] + self.options

  def set_input(self, v):
    assert(0)

class INIT(Stage):
  def __init__(self, v):
    Stage.__init__(self, v)
    self.In =  dict(arg0='user_input1.mif',arg1='user_input2.mif')
    self.Out = dict(affine_out='affine.mat')
    self.command = 'mrreg_init'

class AFFINE(Stage):
  def __init__(self, v):
    Stage.__init__(self, v)
    self.command = 'mrreg_linear'

class OUT(Stage):
  def __init__(self, v):
    Stage.__init__(self, v)
    self.command = None

class RESIZE(Stage):
  def __init__(self, v):
    Stage.__init__(self, v)
    self.command = 'mrresize'

def get_class(t):
  if not t[0].upper() in globals():
    app.error('stage "'+t[0]+'" not defined')
  # isinstance(Stage)
  return globals()[t[0].upper()](t)
# c = get_class(('init','translation=mass'))

S = Sequence()
for i, stage in enumerate(stages):
  S.add(get_class(stage))
for s in S.info():
  app.console(s)


app.complete()

