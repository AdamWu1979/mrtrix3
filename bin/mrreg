#!/usr/bin/env python

# Script for registration


# Make the corresponding MRtrix3 Python libraries available
import inspect, os, sys
lib_folder = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile(inspect.currentframe()))[0], os.pardir, 'lib')))
if not os.path.isdir(lib_folder):
  sys.stderr.write('Unable to locate MRtrix3 Python libraries')
  sys.exit(1)
sys.path.insert(0, lib_folder)


from mrtrix3 import app, image, path, run

choice_init = ['mass', 'search', 'matrix']
choice_linear_type =['rigid', 'affine']

app.init('MRtrix3 (TODO@gmail.com)','Symmetric Registration')
app.cmdline.addDescription('mrreg acts as a script for performing various types of registrations')

app.cmdline.add_argument("input", nargs=2, metavar=('input1','input2'), help='Pair of input images.')


# General options
common_options = app.cmdline.add_argument_group('General options')
common_options.add_argument('-init', choices=choice_init, help='valid choices: '+', '.join(choice_init), default='mass')
common_options.add_argument('-linear', choices=choice_linear_type, help='valid choices: '+', '.join(choice_linear_type), default='affine')
common_options.add_argument('-nonlinear', action='store_true', help='run nonlinear registration')
common_options.add_argument('-lmax', help='The maximum harmonic degree(s)')
common_options.add_argument('-mask1', help='Provide a mask for image1')
common_options.add_argument('-mask2', help='Provide a mask for image2')
# app.cmdline.flagMutuallyExclusiveOptions( [ 'grad', 'fslgrad' ] )

# Import the command-line settings for all algorithms found in the relevant directory
# algorithm.initialise()


app.parse()

# Sanitise some inputs, and get ready for data import
if app.args.lmax:
  try:
    lmax = [ int(x) for x in app.args.lmax.split(',') ]
    if any([lmax_value%2 for lmax_value in lmax]):
      app.error('Value of lmax must be even')
  except:
    app.error('Parameter lmax must be a number')

# app.makeTempDir()
app.console("init: "+ str(app.args.init))
app.console("linear: "+ str(app.args.linear))
if app.args.nonlinear: app.console("nonlinear: "+ str(app.args.nonlinear))
if app.args.lmax:
  app.console("lmax: "+ app.args.lmax)
  # if not (app.args.lmax)
if app.args.mask1:
  app.console("mask1: "+ app.args.mask1)
if app.args.mask2:
  app.console("mask2: "+ app.args.mask2)

mask1 = None
mask2 = None
if app.args.mask1:
  mask1 = path.fromUser(app.args.mask1, True)
  # run.command([['mrconvert',path.fromUser(app.args.mask1, True),'-','-datatype', 'bit'],
               # ['mrtransform','-',path.toTemp('mask1.mif', True),'-template',path.fromUser(app.args.input[0][0], True)]])
if app.args.mask2:
  mask2 = path.fromUser(app.args.mask2, True)
  # run.command([['mrconvert',path.fromUser(app.args.mask2, True),'-','-datatype', 'bit'],
               # ['mrtransform','-',path.toTemp('mask2.mif', True),'-template',path.fromUser(app.args.input[0][1], True)]])

# Get standard input data into the temporary directory
# run.command('mrreg_init ' + path.fromUser(app.args.input, True) + ' ' + path.toTemp('dwi.mif', True) + ' -stride 0,0,0,1' + grad_import_option)



# app.gotoTempDir()

app.complete()
